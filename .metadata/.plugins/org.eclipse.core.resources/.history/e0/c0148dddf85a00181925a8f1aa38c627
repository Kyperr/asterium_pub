package com.toozo.asteriumwebserver.gamelogic;

import java.awt.Color;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

import com.toozo.asteriumwebserver.gamelogic.PlayerCharacter;
import com.toozo.asteriumwebserver.gamelogic.items.AbstractItem;
import com.toozo.asteriumwebserver.sessionmanager.SessionManager;

import actiondata.ActionData;
import actiondata.SyncGameBoardDataRequestData;
import actiondata.SyncPlayerClientDataRequestData;
import message.Request;

/**
 * @author Studio Toozo
 */
public class GameState {
	// ===== STATIC FIELDS =====
	/*
	 * The locations that make up the game map
	 */
	private static Map<String, Location> locations = new HashMap<String, Location>();

	// Initialize the locations
	{
		// Make a new location
		Location home = new Location(Location.LocationType.CONTROL_ROOM);
		// Make a new room with a room id and location
		locations.put("1", home);

		Location med_bay = new Location(Location.LocationType.MED_BAY);
		med_bay.addActivity(Activity.SEARCH, Activity.searchActivity);

		locations.put("2", med_bay);
		locations.put("3", med_bay);
	};
	// =========================
	
	// ===== CONSTANTS =====
	public static final int STARTING_FOOD_PER_PLAYER = 5;
	public static final int STARTING_FUEL = 100;
	// =====================
	
	// ===== ENUMS =====

	private enum GamePhase {

		PLAYERS_JOINING(Game::playerJoining),

		GAME_INITIALIZING(Game::initializeGame),

		PLAYER_TURNS(Game::initiatePlayerTurnPhase),

		TURN_RESOLVE(game -> {

		}),

		TURN_SUMMARY(game -> {

		}),

		END_SUMMARY(game -> {

		}),

		START_SUMMARY(game -> {

		});

		private final Consumer<Game> phaseSequence;

		GamePhase(Consumer<Game> phaseSequence) {
			this.phaseSequence = phaseSequence;
		}

		public void executePhase(Game game) {
			this.phaseSequence.accept(game);
		}

	}
	// =================
	
	// ===== FIELDS =====
	/* Map of player auth token to character */
	private Game game;
	private GamePhase gamePhase;
	private int food;
	private int fuel;
	private Map<String, PlayerCharacter> playerCharacterMap;
	private Collection<VictoryCondition> victoryConditions;
	private Inventory communalInventory;
	// ==================
	
	// ===== CONSTRUCTORS =====
	public GameState(Game game) {
		this.game = game;
		gamePhase = GamePhase.PLAYERS_JOINING;
		this.food = STARTING_FOOD_PER_PLAYER * this.game.getPlayers().size();
		this.fuel = STARTING_FUEL;
		this.playerCharacterMap = new ConcurrentHashMap<String, PlayerCharacter>();
		this.victoryConditions = new ArrayList<VictoryCondition>();
		this.communalInventory = new Inventory();
	}
	// ========================
	
	// ===== GETTERS =====
	public PlayerCharacter getCharacter(final String auth) {
		return playerCharacterMap.get(auth);
	}
	
	/**
	 * @return a {@link Collection} of references to all complete 
	 * 		   {@link VictoryCondition}s in this GameState.
	 */
	public Collection<VictoryCondition> getCompleteVictoryConditions() {
		Collection<VictoryCondition> result = new ArrayList<VictoryCondition>();
		
		// Add all complete victory conditions
		for (VictoryCondition vc : this.victoryConditions) {
			if (vc.isComplete(this)) {
				result.add(vc);
			}
		}
		
		return result;
	}
	
	/**
	 * @return a {@link Collection} of references to this GameState's {@link VictoryCondition}s.
	 */
	public Collection<VictoryCondition> getVictoryConditions() {
		return this.victoryConditions;
	}
	
	/**
	 * Gets a {@link Collection} of the {@link PlayerCharacter}s in the game.
	 * WARNING: Modifications to this Collection will affect 
	 * 			the GameState's map of {@link PlayerCharacter}s.
	 * 
	 * @return Collection<Character> containing the game's Characters.
	 */
	public Collection<PlayerCharacter> getCharacters() {
		return this.playerCharacterMap.values();
	}
	
	/**
	 * @return The communal {@link Inventory} in this GameState.
	 */
	public Inventory getCommunalInventory() {
		return this.communalInventory;
	}
	// ===================
	
	// ===== METHODS =====
	public boolean allCharactersReady() {
		for (Boolean bool : playerReadyMap.values()) {
			if (!bool) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * Toggles whether the {@link PlayerCharacter} belonging
	 * to the {@link Player} with authToken is ready or not.
	 * 
	 * @param authToken The auth token of the {@link Player}
	 */
	public synchronized boolean toggleReady(final String authToken) {
			Player player = this.game.getPlayer(authToken);
			boolean isReady = !playerReadyMap.get(authToken);
			this.playerReadyMap.put(authToken, isReady);
			game.executePhase();
			return isReady;
	}
	
	
	
	/**
	 * Add a {@link Player} to the {@link GameState} when they join the {@link Game}.
	 * 
	 * @param playerAuth The player's auth token
	 * @param character The new character
	 */
	public void addPlayer(final String playerAuth) {
		Player player = this.game.getPlayer(playerAuth);
		PlayerCharacter character = new PlayerCharacter();
		
		this.playerCharacterMap.put(playerAuth, character);
		this.playerReadyMap.put(playerAuth, false);
	}
	
	/**
	 * Add an item to the communal inventory.
	 * 
	 * @param item the {@link AbstractItem} which should be added to the communal {@link Inventory}.
	 */
	public void addCommunalItem(final AbstractItem item) {
		this.communalInventory.add(item);
	}
	

	public void setGamePhase(GamePhase gamePhase) {
		this.gamePhase = gamePhase;
	}
	
	public Location getLocation(String locationID) {
		return this.locations.get(locationID);
	}

	public Set<String> getMapLocations() {
		return this.locations.keySet();
	}

	public Location getAtMapLocation(String mapLocation) {
		return this.locations.get(mapLocation);
	}

	// ===================


	
	// ============Static <Game> Consumers to be
	// used===================================
	private static final void playerJoining(GameState state) {
		System.err.println("Running Player Joining Phase.");
		if (state.allCharactersReady()) {
			// Here is where we would validate game state to make sure everything is ready
			// to start.
			// if(validateGameState()){
			state.setGamePhase(GamePhase.GAME_INITIALIZING);
			state.gamePhase.executePhase(state);
			state.game.setAllCharactersNotReady();
			// }
		}
	}

	private static final void initializeGame(GameState state) {
		System.err.println("Initializing Game.");
		// TODO Initialize game
		state.setGamePhase(GamePhase.PLAYER_TURNS);
		state.gamePhase.executePhase(state);
	}

	private static final void initiatePlayerTurnPhase(GameState state) {
		syncPlayerClients(state);
		syncGameBoards(state);
	}

	private static final void syncPlayerClients(GameState state) {
		System.err.println("Sending player client sync.");
		List<SyncPlayerClientDataRequestData.LocationData> loc = new ArrayList<>();

		for (String s : state.getMapLocations()) {
			Location l = state.getAtMapLocation(s);
			// if(l.distance <= player.stamina)//pseudocode

			SyncPlayerClientDataRequestData.LocationData locData = new SyncPlayerClientDataRequestData.LocationData(s,
					l.getType().getJSONVersion(), l.getActivityNames());

			loc.add(locData);
		}

		for (Player p : state.game.getPlayers()) {
			String auth = p.getAuthToken();

			PlayerCharacter pChar = state.getCharacter(auth);

			SyncPlayerClientDataRequestData.Character.Stats stat = new SyncPlayerClientDataRequestData.Character.Stats(
					pChar.getEffectiveStats().getHealth(),
					pChar.getEffectiveStats().getStamina(),
					pChar.getEffectiveStats().getLuck(),
					pChar.getEffectiveStats().getIntuition());

			SyncPlayerClientDataRequestData.Character dChar = new SyncPlayerClientDataRequestData.Character(pChar.getCharacterName(), stat);

			
			SyncPlayerClientDataRequestData data = new SyncPlayerClientDataRequestData(loc, dChar);
			
			Request request = new Request(data, auth);
			
			try {
				SessionManager.getInstance().getSession(auth).getBasicRemote().sendText(request.jsonify().toString());
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
		}

	}

	private static final void syncGameBoards(GameState state) {
		int food;
		int fuel;
		// Construct collection of LocationData
		Collection<SyncGameBoardDataRequestData.LocationData> locationDatas = new ArrayList<SyncGameBoardDataRequestData.LocationData>();
		SyncGameBoardDataRequestData.LocationData location;
		for (String mapLocation : state.getMapLocations()) {
			location = new SyncGameBoardDataRequestData.LocationData(mapLocation,
					state.getAtMapLocation(mapLocation).getType().toString());
			locationDatas.add(location);
		}

		// Construct collection of PlayerData
		Collection<SyncGameBoardDataRequestData.PlayerCharacterData> playerDatas = new ArrayList<SyncGameBoardDataRequestData.PlayerCharacterData>();
		SyncGameBoardDataRequestData.PlayerCharacterData player;
		for (final PlayerCharacter c : state.getCharacters()) {
			player = new SyncGameBoardDataRequestData.PlayerCharacterData(c.getCharacterName(), 
															Color.WHITE, 
															"home_base");
			playerDatas.add(player);
		}

		// Construct collection of VictoryData
		Collection<SyncGameBoardDataRequestData.VictoryData> victoryDatas = new ArrayList<SyncGameBoardDataRequestData.VictoryData>();
		SyncGameBoardDataRequestData.VictoryData victory;
		for (final VictoryCondition vc : state.getVictoryConditions()) {
			victory = new SyncGameBoardDataRequestData.VictoryData(vc.getName(), 
																   vc.getProgress(state),
																   VictoryCondition.COMPLETE_THRESHOLD);
			victoryDatas.add(victory);
		}

		// Get communal inventory data
		Collection<SyncGameBoardDataRequestData.ItemData> itemDatas = new ArrayList<SyncGameBoardDataRequestData.ItemData>();
		SyncGameBoardDataRequestData.ItemData itemData;
		for (final AbstractItem item : state.getCommunalInventory()) {
			itemData = new SyncGameBoardDataRequestData.ItemData(item.getName());
			itemDatas.add(itemData);
		}

		//ActionData displayBoardRequestData = new SyncGameBoardDataRequestData();
		// Message displayBoardMessage = new Request(displayBoardRequestData,
		// "DanielSaysToLeaveTheAuthTokenBlank");

		for (GameBoard gameBoard : state.game.getGameBoards()) {
			// gameBoard.getSession().sendMessage(displayBoardMessage);
		}

		// TODO Send DisplayOptions to all players
		state.setGamePhase(GamePhase.TURN_RESOLVE);
	}
}
