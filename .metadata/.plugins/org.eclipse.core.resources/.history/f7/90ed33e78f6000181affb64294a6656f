package com.toozo.asteriumwebserver.gamelogic.items;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.function.Supplier;

import com.toozo.asteriumwebserver.gamelogic.PlayerCharacter;

public class LootPool {
	/*
	ItemSupplier(Supplier<Item> item, float basePercentChange, float luckWeight, float intuitionWeight)
    -getItem
    -getBaseChance
    -getLuckWeight
    -getIntuitionWeight
    -getEffectiveChance(Stats stats)//Idk about this.
    
Note: The above ItemSupplier class could also take a Function<Game, Boolean> that could be used
to make the item conditional. An example of this would be an item that is only available if 
nobody already has the item, such as a victory condition item. Essentially, if the function 
supplier returns false, the getEffectiveChance() will return 0.0

    
LootPool(List<ItemSupplier> itemSuppliers)
    -List<ItemSupplier>
    -getRandomItem()//This would simply use the ItemSupplier.baseChance
    -getRandomItemFor(Player p)//This would weight probabilities on the p's stats.
    
	// Here is a rough example of how this could work.
    public Item getRandomItemFor(Player p){
    
        int totalSumChance = 0f;
        
        for(ItemSupplier is : this.itemSuppliers){
            totalSumChance += is.getEffectiveChance(p.getStats());
        }
        
        int index = this.(secure rand).nextFloat(totalSumChance);
        int sum = 0;
        int i = 0;
        while(sum < index){
            sum += this.itemSuppliers.get(i++).getEffectiveChance(p.getStats());
        }
        
        ItemSupplier randIS = this.itemSuppliers.get(Math.max(0, i-1));
        return randIS.getItem();
    
    }
    */
	
	// ===== CONSTANTS =====
	public static final Map<Integer, Double> ITEM_NUMBER_PROBABILITIES;
	static {
		Map<Integer, Double> probs = new HashMap<Integer, Double>();
		probs.put(1, 0.40);
		probs.put(2, 0.20);
		probs.put(3, 0.10);
		probs.put(4, 0.05);
		probs.put(5, 0.05);
		ITEM_NUMBER_PROBABILITIES = Collections.unmodifiableMap(probs);
	}

	private static final Random RNG = new Random();
	
	// =====================
	
	// ===== FIELDS =====
	private List<ItemLoot> items;
	// ==================
	
	// ===== CONSTRUCTORS =====
	/**
	 * Constructs a new LootPool based on lootProbabilities.
	 * 
	 * @param lootProbabilities a {@link Map} from (? extends AbstractItem)::new to
	 * 							the probability that that item should be looted from this room.
	 */
	public LootPool(List<ItemLoot> lootItems) {
		this.items = lootItems;
	}
	// ========================
	
	// ===== METHODS =====
	/**
	 * @return a {@link Collection} of {@link AbstractItem}s gained from looting this loot pool.
	 */
	public List<AbstractItem> loot() {
		List<AbstractItem> result = new ArrayList<AbstractItem>();
		/*
		for (ItemLoot item : this.probabilities) {;
			double random = RNG.nextDouble();
			if (random < probability) {
				result.add(constructor.get());
			}
		}
		*/
		return result;
	}
	
	/**
	 * @param numberOfItems The number of {@link AbstractItem}s that should 
	 * 						be in the {@link Collection} returned.
	 * @return a {@link Collection} of {@link AbstractItem}s pulled from this loot pool.
	 */
	public Collection<AbstractItem> lootItems(int numberOfItems) {
		List<AbstractItem> items = new ArrayList<AbstractItem>();
		
		// Keep looting until you have at least numberOfItems
		while (items.size() < numberOfItems) {
			items.addAll(loot());
		}
		
		// Return numberOfItems' worth of items
		Collections.shuffle(items);
		return items.subList(0, numberOfItems);
	}
	
	/**
	 * @return an {@link AbstractItem} pulled from this loot pool based on looter's stats.
	 */
	public AbstractItem lootItem(PlayerCharacter looter) {
        int totalSumChance = 0;
        
        for(ItemLoot is : this.items){
            totalSumChance += is.getEffectiveChance(p.getStats());
        }
        
        int index = RNG.nextInt(totalSumChance);
        int sum = 0;
        int i = 0;
        while(sum < index){
            sum += this.itemSuppliers.get(i++).getEffectiveChance(p.getStats());
        }
        
        ItemSupplier randIS = this.itemSuppliers.get(Math.max(0, i-1));
        return randIS.getItem();
	}
	
	// ===================
}
